---
title: 受检异常
date: 2025-09-04
---
“受检异常必须用`throws`声明，否则编译报错”，需要先从 Java 设计受检异常的**核心目的**入手 —— 它是编译器强制开发者 “正视风险、明确责任” 的机制，确保可能发生的可预见风险（如文件找不到、网络断开）不会被遗漏处理。下面分 3 个层面详细解释：
### 1. 先明确：什么是 “受检异常”？

Java 的异常体系中，所有继承自`Exception`但**不继承自`RuntimeException`** 的异常，都属于 “受检异常”（Checked Exception）。  
常见例子：

- `IOException`：操作文件 / 流时可能发生（如文件不存在、权限不足）；
- `SQLException`：操作数据库时可能发生（如连接失败、SQL 语法错误）；
- `ClassNotFoundException`：加载类时可能发生（如类路径错误）。

这类异常的特点是：**它们是 “可预见、可处理” 的风险**（比如文件可能不存在，开发者可以提前判断或事后补救），因此 Java 编译器会强制介入 —— 要求开发者必须明确 “如何处理这种风险”。

### 2. 为什么必须用`throws`声明？本质是 “责任传递”

当方法内部执行了可能抛出受检异常的代码（比如`new FileReader("test.txt")`会抛出`FileNotFoundException`，属于`IOException`的子类），意味着**当前方法无法独自处理这个风险**（或选择不处理，交给调用者处理）。

此时用`throws`在方法声明处声明异常，本质是做两件事：

- **向编译器 “报备”**：告诉编译器 “我知道这个方法可能抛出 XX 异常，我不在这里处理，会交给调用者处理”，避免编译器判定为 “遗漏风险”；
- **向调用者 “声明责任”**：告诉调用该方法的其他代码 “你调用我时，必须处理我声明的这些异常，否则你也会编译报错”—— 形成 “风险责任链”，直到某个层级的代码能真正处理（用`try-catch`捕获）。

```java
// 错误示例：方法内抛受检异常，却没声明throws
public void readFile() {
    // 这里new FileReader会抛出受检异常FileNotFoundException（属于IOException）
    FileReader fr = new FileReader("test.txt"); // 编译报错：未报告的异常FileNotFoundException
}
```

编译器会直接报错，因为它发现：方法内存在 “可能抛出受检异常” 的代码，但开发者既没在方法内用`try-catch`处理，也没声明 “交给调用者处理”—— 相当于 “逃避风险责任”，编译器不允许这种情况。

### 3. 不声明`throws`会编译报错：编译器的 “强制监督”

Java 编译器对受检异常的处理有**强制规则**：

> 若一个方法内部包含 “可能抛出受检异常” 的代码（无论是自己`throw`的，还是调用其他方法时继承的），则该方法必须满足以下两个条件之一，否则编译不通过：
> 
> 1. 用`try-catch`块**捕获并处理**该异常（自己承担责任）；
>
> 2. 用`throws`在方法声明处**声明该异常**（将责任传递给调用者）。

这就是 “不声明`throws`会编译报错” 的底层原因 —— 编译器要确保 “每一个受检异常的风险，都有明确的处理责任人”，避免开发者因疏忽遗漏风险，导致程序运行时突然崩溃。
