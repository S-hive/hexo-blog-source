---
date: 2025-08-18
title: 哈希表核心原理
---
请问，哈希表和我们常说的 Map（键值映射）是不是同一个东西？不是。

Map 是接口，哈希表是实现，Map还有其他实现方式。

## [哈希表的基本原理](https://labuladong.online/algo/data-structure-basic/hashmap-basic/#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86) 

哈希表可以理解为一个加强版的数组。

数组可以通过索引在 O(1)O(1) 的时间复杂度内查找到对应元素，索引是一个非负整数。

哈希表是类似的，可以通过 `key` 在 O(1)O(1) 的时间复杂度内查找到这个 `key` 对应的 `value`。`key` 的类型可以是数字、字符串等多种类型。

怎么做的？特别简单，哈希表的底层实现就是一个数组（我们不妨称之为 `table`）。它先把这个 `key` 通过一个哈希函数（我们不妨称之为 `hash`）转化成数组里面的索引，然后增删查改操作和数组基本相同：

```java
// 哈希表伪码逻辑
class MyHashMap {

    private Object[] table;

    // 增/改，复杂度 O(1)
    public void put(K key, V value) {
        int index = hash(key);
        table[index] = value;
    }

    // 查，复杂度 O(1)
    public V get(K key) {
        int index = hash(key);
        return table[index];
    }

    // 删，复杂度 O(1)
    public void remove(K key) {
        int index = hash(key);
        table[index] = null;
    }

    // 哈希函数，把 key 转化成 table 中的合法索引
    // 时间复杂度必须是 O(1)，才能保证上述方法的复杂度都是 O(1)
    private int hash(K key) {
        // ...
    }
}
```

## [几个关键概念及原理](https://labuladong.online/algo/data-structure-basic/hashmap-basic/#%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%8E%9F%E7%90%86) 

### `key` 是唯一的，`value` 可以重复

### 哈希函数

哈希函数的作用是把任意长度的输入（key）转化成固定长度的输出（索引）。
你也看到了，增删查改的方法中都会用到哈希函数来计算索引，如果你设计的这个哈希函数复杂度是 O(N)O(N)，那么哈希表的增删查改性能就会退化成 O(N)O(N)，**所以说这个函数的性能很关键**。

**这个函数还要保证的一点是，输入相同的 `key`，输出也必须要相同，这样才能保证哈希表的正确性**。不能说现在你计算 `hash("123") = 5`，待会儿计算 `hash("123") = 6`，这样的话哈希表就废了。

### 哈希冲突

哈希冲突不可能避免，只能在算法层面妥善处理出现哈希冲突的情况。

哈希冲突是一定会出现的，因为这个 `hash` 函数相当于是把一个无穷大的空间映射到了一个有限的索引空间，所以必然会有不同的 `key` 映射到同一个索引上。

出现哈希冲突的情况怎么解决？两种常见的解决方法，一种是**拉链法**，另一种是**线性探查法**（也经常被叫做**开放寻址法**）。

名字听起来高大上，说白了就是纵向延伸和横向延伸两种思路嘛：
![[Pasted image 20250818205143.png]]

### 扩容和负载因子

负载因子是一个哈希表装满的程度的度量。一般来说，负载因子越大，说明哈希表里面存储的 `key-value` 对越多，哈希冲突的概率就越大，哈希表的操作性能就越差。

**负载因子的计算公式也很简单，就是 `size / table.length`**。其中 `size` 是哈希表里面的 `key-value` 对的数量，`table.length` 是哈希表底层数组的容量。

