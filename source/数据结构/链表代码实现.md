---
title: 链表代码实现
date: 2027-07-18
cssclasses:
  - 数据结构
  - 链表
---
## 关键点一、同时持有头尾节点的引用

在力扣做题时，一般题目给我们传入的就是单链表的头指针。但是在实际开发中，用的都是双链表，而双链表一般会同时持有头尾节点的引用。

因为在软件开发中，在容器尾部添加元素是个非常高频的操作，双链表持有尾部节点的引用，就可以在 O(1)的时间复杂度内完成尾部添加元素的操作。

对于单链表来说，持有尾部节点的引用也有优化效果。比如你要在单链表尾部添加元素，如果没有尾部节点的引用，你就需要遍历整个链表找到尾部节点，时间复杂度是 O(n)；如果有尾部节点的引用，就可以在 O(1 的时间复杂度内完成尾部添加元素的操作。

细心的读者可能会说，即便如此，如果删除一次单链表的尾结点，那么之前尾结点的引用就失效了，还是需要遍历一遍链表找到尾结点。

是的，但你再仔细想想，删除单链表尾结点的时候，是不是也得遍历到倒数第二个节点（尾结点的前驱），才能通过指针操作把尾结点删掉？那么这个时候，你不就可以顺便把尾结点的引用给更新了吗？

## 关键点二、虚拟头尾节点

在创建双链表时就创建一个虚拟头节点和一个虚拟尾节点，无论双链表是否为空，这两个节点都存在。这样就不会出现空指针的问题，可以避免很多边界情况的处理。

有了头尾虚拟节点，无论链表是否为空，都只需要考虑在中间插入元素的情况就可以了，这样代码会简洁很多。

对于单链表，虚拟头结点有一定的简化作用，但虚拟尾节点没有太大作用。

>虚拟节点是你内部实现数据结构的技巧，对外是不可见的。

## 关键点三、内存泄露？

在前文动态数组实现中，提到了删除元素时，要注意内存泄露的问题。那么在链表中，删除元素会不会也有内存泄露的问题呢？
```java
// 删除单链表头结点 head = head.next;
head = head.next;
```
实际上这样写是 OK 的，因为 Java 的垃圾回收的判断机制是看这个对象是否被别人引用，而并不会 care 这个对象是否还引用着别人。

不过呢，删除节点时，最好还是把被删除节点的指针都置为 null，这是个好习惯，不会有什么代价，还可能避免一些潜在的问题。

## 双链表代码实现

参考力扣第 707 题「[设计链表](https://leetcode.cn/problems/design-linked-list/)」
```java
class MyLinkedList {

    Node head, tail;
    int size;
    class Node {
        Node next, prev;
        int val;
        Node(int val) {
            this.val = val;
        }
    }
    public MyLinkedList() {
        this.head = new Node(-1);
        this.tail = new Node(-1);
        this.size = 0;
        this.tail.prev = this.head;
        this.head.next = this.tail;
    }
    
    public int get(int index) {
        if (!checkGetHasNode(index)) {
            return -1;
        } else {
            Node cur;
            cur = findFrontIndexNode(index);
            return cur.next.val;
        }
    }
    
    public void addAtHead(int val) {
        Node newNode = new Node(val);
        Node hasNext = this.head.next;
        this.head.next = newNode;
        newNode.next = hasNext;
        hasNext.prev = newNode;
        newNode.prev = this.head;
        this.size++;
    }
    
    public void addAtTail(int val) {
        Node newNode = new Node(val);
        Node hasTail = this.tail.prev;
        hasTail.next = newNode;
        newNode.next = this.tail;
        this.tail.prev = newNode;
        newNode.prev = hasTail;
        this.size++;
    }
    
    public void addAtIndex(int index, int val) {
        if (!checkAddHasNode(index)) {

        } else if (index == this.size) {
            addAtTail(val);
        } else {
            Node cur;
            cur = findFrontIndexNode(index);
            Node hasNext = cur.next;
            Node newNode = new Node(val);
            cur.next = newNode;
            newNode.next = hasNext;
            hasNext.prev = newNode;
            newNode.prev = cur;
            this.size++;
        }
    }
    
    public void deleteAtIndex(int index) {
        if (checkGetHasNode(index)) {
            Node cur = findFrontIndexNode(index);
            Node hasNext = cur.next.next;
            cur.next = hasNext;
            hasNext.prev = cur;
            this.size--;
        }
    }

    public Node findFrontIndexNode(int index) {
        if (!checkGetHasNode(index)) {
            return null;
        } else {
            Node cur = this.head;
            for (int i = 0; i < index; i++) {
                cur = cur.next;
            }
            return cur;
        }
    }

    public boolean checkAddHasNode(int index) {
        return index <= this.size;
    }

    public boolean checkGetHasNode(int index) {
        return index < this.size;
    }
}
```

## 单链表代码实现

```java
class MyLinkedList {

    Node head,tail;
    int size;
    class Node {
        int val;
        Node next;
        Node(int val) {
            this.val = val;
            this.next = null;
        }
    }
    public MyLinkedList() {
        this.head = new Node(-1); //虚拟头节点
        this.tail = this.head; //实际尾节点
        this.size = 0;
    }
    
    public int get(int index) {
        if (!checkGetIndex(index)) {
            return -1;
        } else {
            Node cur = findFountIndex(index);
            return cur.next.val;
        }
    }
    
    public void addAtHead(int val) {
        //当链表为空时（size == 0），添加头节点后尾指针 tail 未更新
        Node newNode = new Node(val);
        Node hasnext = this.head.next;
        this.head.next = newNode;
        newNode.next = hasnext;
        if (this.size == 0){
            this.tail = newNode;
        }
        this.size++;
        
    }
    
    public void addAtTail(int val) {  
        //添加元素后，旧的尾节点仍留在列表中，破坏了预期的结构。
        Node newNode = new Node(val);
        this.tail.next = newNode;
        this.tail = newNode;
        this.size++;
    }
    
    public void addAtIndex(int index, int val) {
        if (!checkAddIndex(index)) {
        
        } else if (index == this.size) {
            addAtTail(val);
        } else {
            Node cur = findFountIndex(index);
            Node newNode = new Node(val);
            Node hasnext = cur.next;
            cur.next = newNode;
            newNode.next = hasnext;
            this.size++;
        }
    }
    
    public void deleteAtIndex(int index) {
        if ( index == this.size - 1 ) {
            Node cur = findFountIndex(index);
            this.tail = cur;
            this.size--;
            } else if (checkGetIndex(index)) {
                Node cur = findFountIndex(index);
                cur.next = cur.next.next;
                this.size--;
        }
    }

    public Node findFountIndex(int index) {
        //if (checkGetIndex(index)) {
        Node cur = this.head;
        for (int i = 0; i < index; i++ ) {
            cur = cur.next;
        }
        return cur;
        
        //return null;
        /**当 checkGetIndex(index) 为 false 时返回 null，但调用它的方法（如 get、addAtIndex 等 ），未充分校验返回值是否为 null，直接用 cur.next 就会触发 NullPointerException。*/
    }

    public boolean checkGetIndex(int index) {
        return index < this.size;
    }

    public boolean checkAddIndex(int index) {
        return index <= this.size;
    }
}
```