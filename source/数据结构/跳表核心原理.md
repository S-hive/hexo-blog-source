---
title: 跳表核心原理
date: 2025-07-29
cssclasses:
  - 数据结构
  - 数组
---
单链表增删查改**指定索引**元素的操作的时间主要消耗在「通过索引查找节点」的遍历过程，而非操作本身。

那么，我们是否可以通过一些优化方式，让链表支持快速的查找操作呢？

有一种方式是借助键值映射，用 O(1)O(1) 的时间直接拿到目标节点，避免了遍历查找的时间消耗，这个思路在后面的 哈希链表（LinkedHashMap）
中会详细介绍。

另一种方式，这就是本文介绍的跳表（Skip List），利用**空间换时间**的思想，用额外的空间记录额外的信息，增删查改的时间复杂度都能优化到 O(log⁡N)

## 跳表核心原理

我们就以查询指定索引的元素为例，来看看跳表是如何优化单链表的。

一条普通的单链表长这样：

```
index  0  1  2  3  4  5  6  7  8  9
node   a->b->c->d->e->f->g->h->i->j
```

如果我们想查询索引为 7 的元素是什么，只能从索引 0 头结点开始往后遍历，直到遍历到索引 7，找到目标节点 `h`。

而跳表则是这样的：

```
indexLevel   0-----------------------8-----10
indexLevel   0-----------4-----------8-----10
indexLevel   0-----2-----4-----6-----8-----10
indexLevel   0--1--2--3--4--5--6--7--8--9--10
nodeLevel    a->b->c->d->e->f->g->h->i->j->k
```

跳表相当于在原链表的基础上，增加了多层索引，**每向上一层，索引节点的数量减少一半，索引的间隔变为 2 倍**，所以索引的高度是 log⁡NlogN，NN 代表链表中元素的个数。

此时，如果我们想查询索引为 7 的元素，可以从最高层索引开始一层一层地往下找：

首先最高层的第一个索引区间是 `[0, 8]`，可以确定索引 7 在这个区间内，所以从下一层的节点 0 开始搜索；

第二层从节点 0 开始，索引区间 `[0, 4]` 不包含索引 7，继续往右移动到节点 4，索引区间 `[4, 8]` 包含索引 7，所以从下一层的节点 4 开始搜索；

第三层从节点 4 开始，索引区间 `[4, 6]` 不包含索引 7，继续往右移动到节点 6，索引区间 `[6, 8]` 包含索引 7，所以从下一层的节点 6 开始搜索；

第四层从节点 6 开始，索引区间 `[6, 7]` 包含索引 7，最终找到目标节点 `h`。

这个搜索过程中，会经过 log⁡NlogN 层索引，在每层索引中移动的次数不会超过 2 次（因为上层索引区间在下一层被分为两半），所以跳表的查询时间复杂度是 O(log⁡N)O(logN)。