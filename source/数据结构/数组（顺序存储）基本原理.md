---
date: 2025-07-15
title: 数组（顺序存储）基本原理
cssclasses:
  - 数据结构
  - 数组
---
## 静态/动态数组实质

* 「静态数组」就是一块**连续的内存空间**，我们可以通过索引来访问这块内存空间中的元素，这是数组的原始形态。
* 「动态数组」是编程语言为了方便我们使用，在静态数组的基础上帮我们添加了一些常用的      API，比如 `push, insert, remove` 等等方法

## 静态数组

静态数组在创建的时候就要确定数组的元素类型和元素数量。
>只有在 C++、Java、Golang 这类语言中才提供了创建静态数组的方式，类似 Python、JavaScript 这类语言并没有提供静态数组的定义方式

#### 定义一个静态数组的方法：
```java
// 定义一个大小为 10 的静态数组
int[] arr = new int[10];

// 使用索引赋值
arr[0] = 1;
arr[1] = 2;

// 使用索引取值
int a = arr[0];
```

```python
# 严格来说，Python 没有静态数组的定义方式
# 我们暂且使用列表模拟静态数组

# 定义一个大小为 10 的静态数组
arr = [0] * 10

# 使用索引赋值
arr[0] = 1
arr[1] = 2

# 使用索引取值
a = arr[0]
```

#### 内核操作
`int arr[10]` 这段代码到底做了什么事情呢？
1. 在内存中开辟了一段**连续的内存空间**，大小是 `10 * sizeof(int)` 字节。一个 int 在计算机内存中占 4 字节，也就是总共 40 字节。
2. 定义了一个名为 `arr` 的数组指针，指向这段内存空间的首地址。

 `arr[1] = 2` 这段代码又做了什么事情呢？
1. 计算 `arr` 的首地址加上 `1 * sizeof(int)` 字节（4 字节）的偏移量，找到了内存空间中的第二个元素的**首地址**。
2. 从这个地址开始的 4 个字节的内存空间中写入了整数 `2`。

>1. 为什么数组的索引从 0 开始？
	就是方便取地址。`arr[0]` 就是 `arr` 的首地址，就是 `arr` 的首地址加上 `0 * 4` 字节,从这个地址往后的 4 个字节存储着第一个元素的值；`arr[1]` 就是 `arr` 的首地址加上 `1 * 4` 字节，也就是第二个元素的首地址，这个地址往后的 4 个字节存储着第二个元素的值。`arr[2], arr[3]` 以此类推。
>2. 因为数组的名字 `arr` 就指向整块内存的首地址，所以数组名 `arr` 就是一个指针。你直接取这个地址的值，就是第一个元素的值。也就是说，`*arr` 的值就是 `乘以arr[0]`，即第一个元素的值
	
==内存空间首地址已知、大小已知、内存空间连续，所以，我们获得了数组的超能力「**随机访问」**：只要给定任何一个数组索引，我可以在 O(1)O(1) 的时间内直接获取到对应元素的值。
因为我可以通过首地址和索引直接计算出目标元素的内存地址。计算机的内存寻址时间可以认为是 O(1)O(1)，所以数组的随机访问时间复杂度是 O(1)O(1)。==

### 增删查改

#### 增
##### 末尾追加 - 时间复杂度是 O(1)

```java
// 大小为 10 的数组已经装了 4 个元素
int[] arr = new int[10];
for (int i = 0; i < 4; i++) {
    arr[i] = i;
}

// 现在想在数组末尾追加一个元素 4
arr[4] = 4;

// 再在数组末尾追加一个元素 5
arr[5] = 5;

// 依此类推
// ...
```

```python
# 大小为 10 的数组已经装了 4 个元素
arr = [0] * 10
for i in range(4):
    arr[i] = i

# 现在想在数组末尾追加一个元素 4
arr[4] = 4

# 再在数组末尾追加一个元素 5
arr[5] = 5

# 依此类推
# ...
```

##### 中间插入 - 时间复杂度是 O(N)

这就要涉及「数据搬移」，给新元素腾出空位，然后再才能插入新元素。

```java
// 大小为 10 的数组已经装了 4 个元素
int[] arr = new int[10];
for (int i = 0; i < 4; i++) {
    arr[i] = i;
}

// 在索引 2 置插入元素 666
// 需要把索引 2 以及之后的元素都往后移动一位
// 注意要倒着遍历数组中已有元素避免覆盖，不懂的话请看下方可视化面板
for (int i = 4; i > 2; i--) {
    arr[i] = arr[i - 1];
}

// 现在第 3 个位置空出来了，可以插入新元素
arr[2] = 666;
```

```python
# 大小为 10 的数组已经装了 4 个元素
arr = [0] * 10
for i in range(4):
    arr[i] = i
for i in range(4, 2, -1):
    arr[i] = arr[i - 1]
# 现在第 3 个位置空出来了，可以插入新元素
arr[2] = 666
```

##### 数组空间已满 - 时间复杂度是 O(N)

**连续内存必须一次性分配，分配完了之后就不能随意增减了**。因为你这块连续内存后面的内存空间可能已经被其他程序占用了，不能说你想要就给你。
那怎么办呢？只能重新申请一块更大的内存空间，把原来的数据复制过去，再插入新的元素，这就是数组的「扩容」操作。

```java
// 大小为 10 的数组已经装满了
int[] arr = new int[10];
for (int i = 0; i < 10; i++) {
    arr[i] = i;
}

// 现在想在数组末尾追加一个元素 10
// 需要先扩容数组
int[] newArr = new int[20];
// 把原来的 10 个元素复制过去
for (int i = 0; i < 10; i++) {
    newArr[i] = arr[i];
}

// 旧数组的内存空间将由垃圾收集器处理
// ...

// 在新的大数组中追加新元素
newArr[10] = 10;
```

```python
# 大小为 10 的数组已经装满了
arr = [i for i in range(10)]

newArr = [0] * 20
for i in range(10):
    newArr[i] = arr[i]

# 释放旧数组的内存空间
# 在新的大数组中追加新元素
newArr[10] = 10
```

#### 删

##### 删除末尾元素 - 时间复杂度是 O(1)

直接把末尾元素标记为一个特殊值代表已删除就行了，我们这里简单举例，就用 -1 作为特殊值代表已删除好了。

```java
// 大小为 10 的数组已经装了 5 个元素
int[] arr = new int[10];
for (int i = 0; i < 5; i++) {
    arr[i] = i;
}

// 删除末尾元素，暂时用 -1 代表元素已删除
arr[4] = -1;
```

```python
# 大小为 10 的数组已经装了 5 个元素
arr = [0] * 10
for i in range(5):
    arr[i] = i

# 删除末尾元素，暂时用 -1 代表元素已删除
arr[4] = -1
```

##### 删除中间元素 - 时间复杂度是 O(N)

这也要涉及「数据搬移」，把被删元素后面的元素都往前移动一位，保持数组元素的连续性。

```java
// 大小为 10 的数组已经装了 5 个元素
int[] arr = new int[10];
for (int i = 0; i < 5; i++) {
    arr[i] = i;
}

// 删除 arr[1]
// 需要把 arr[1] 之后的元素都往前移动一位
// 注意要正着遍历数组中已有元素避免覆盖，不懂的话请看下方可视化面板
for (int i = 1; i < 4; i++) {
    arr[i] = arr[i + 1];
}

// 最后一个元素置为 -1 代表已删除
arr[4] = -1;
```

```python
# 大小为 10 的数组已经装了 5 个元素
arr = [0] * 10
for i in range(5):
    arr[i] = i
for i in range(1, 4):
    arr[i] = arr[i + 1]

# 最后一个元素置为 -1 代表已删除
arr[4] = -1
```

## 总结

综上，静态数组的增删查改操作的时间复杂度是：

1. 增：
    - 在末尾追加元素：O(1)O(1)。
    - 在中间（非末尾）插入元素：O(N)O(N)。
2. 删：
    - 删除末尾元素：O(1)O(1)。
    - 删除中间（非末尾）元素：O(N)O(N)。
3. 查：给定指定索引，查询索引对应的元素的值，时间复杂度 O(1)O(1)。
4. 改：给定指定索引，修改索引对应的元素的值，时间复杂度 O(1)O(1)。


## 动态数组

**动态数组底层还是静态数组，只是自动帮我们进行数组空间的扩缩容，并把增删查改操作进行了封装，让我们使用起来更方便而已**。

```java
// 创建动态数组
// 不用显式指定数组大小，它会根据实际存储的元素数量自动扩缩容
ArrayList<Integer> arr = new ArrayList<>();

for (int i = 0; i < 10; i++) {
    // 在末尾追加元素，时间复杂度 O(1)
    arr.add(i);
}

// 在中间插入元素，时间复杂度 O(N)
// 在索引 2 的位置插入元素 666
arr.add(2, 666);

// 在头部插入元素，时间复杂度 O(N)
arr.add(0, -1);

// 删除末尾元素，时间复杂度 O(1)
arr.remove(arr.size() - 1);

// 删除中间元素，时间复杂度 O(N)
// 删除索引 2 的元素
arr.remove(2);

// 根据索引查询元素，时间复杂度 O(1)
int a = arr.get(0);

// 根据索引修改元素，时间复杂度 O(1)
arr.set(0, 100);

// 根据元素值查找索引，时间复杂度 O(N)
int index = arr.indexOf(666);
```

```python
# 创建动态数组
# 不用显式指定数组大小，它会根据实际存储的元素数量自动扩缩容
arr = []

for i in range(10):
    # 在末尾追加元素，时间复杂度 O(1)
    arr.append(i)

# 在中间插入元素，时间复杂度 O(N)
# 在索引 2 的位置插入元素 666
arr.insert(2, 666)

# 在头部插入元素，时间复杂度 O(N)
arr.insert(0, -1)

# 删除末尾元素，时间复杂度 O(1)
arr.pop()

# 删除中间元素，时间复杂度 O(N)
# 删除索引 2 的元素
arr.pop(2)

# 根据索引查询元素，时间复杂度 O(1)
a = arr[0]

# 根据索引修改元素，时间复杂度 O(1)
arr[0] = 100

# 根据元素值查找索引，时间复杂度 O(N)
index = arr.index(666)
```